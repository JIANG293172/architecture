1.use let for constant immultable property, use var for variable multable proerpty

2.value type use copy-on-write on assignment, while reference type share the same instance.

3.optional means the value can be exist or nil, we can use if let to unwrap it, or guart let for earaly exit.

4.ues double question mark to provide a default value if the optional is nil.

5.when tow objects hold strong reference form each others. perventing deallocation.

6.automatic reference counting tracks the number of strong references to an object and dallocates it when count reaches zero.

7.weak is optional; the object will be set to nil when deallocated. unowned is non-optional; accessing the object after it is deallocated will cause a crash.

8.copy-on-write is an optimization for value type in swift, copy the struct only when modified and refercount is greater than one, struct hold some properties: refercount elements count buffer, pointer the memoery in heap.

9.A closure is an implicit function; it can capture variables from its surrounding context, and a closure is connected to a pointer to the executable function code, the captured variables, and a flag to mark whether it is an escaping closure.

10.a closure is called after the function returns, requiring clarity memory management.

11.what are generics?
We do not use the centain type, use T to represent a type of value used by input and output. 
they allow writing flexible, reusable code that works with any teyps.


12.a blueprint of methods or properties that a class, struct or enum, must implement.
swift protocol provide more functions, protocol extension provide default implementions and computed properties.

13.protocol extension provide a defalut implementions for protocol.

14.self refer to the instance, Self refer to the Type.

15.enum associated values: the enum case can store additional data of different types.

16.computed property: a perpery that doesn‘t store value but provide get/set to calculate one.

17.lazy property: a object  be initialized  when first accessed.

18.Any, AnyObject： any is refer to Any type, AnyObject is refer to classes.

19.defer: it ensure a closure code runs after levaving the scope.

20.tuple: a grouping of multiple values into a single cmobined value

21. Type aliascing: giving a new name to an existing type for clarity.

22.failable initializer: an init that can reture nil if initializarion fials.

23. final keyword: prevents a class from being inherited or a method from being overridden.

24.designated is primary init, convenience initializer must call a designanted init for the same class.

25.what is singleton
a pattern ensuring a class has only one instance with a global pointer of accesss.

26.error protocol is a type representing values that can be thrown as errors.

27.do catch blocks: a mechanism to handle errors thrown by functions.

28.try? tyr!: try? returns an optional; try! crashes if an error is thrown.

29.opaque type (some): hides the centain reutrn type while ensuring it conforms to a protocol.

30.result type: a enum representing success with a value or failure with an error.
such as we use in combine, we use future to replace callback closure, the promise is type of Result, use success to return value, and failure to return error.

31.perperty wrapper: a layer of logic between property storage and definition.
Property Wrappers are a powerful Swift feature that lets you encapsulate property storage and access logic in a reusable way.

32.explain keypath: a way refer to a property of a type without invoking it.
let nameKeyPath: KeyPath<Person, String> = \Person.name

33.dynamicCallable: allows instances of type to be called like functions.

34.codable: typealias for encodable & decoable, used for json parsing.

35.String & NSString: String is a value type, while NSString is a reference type, inherite form nsobjedct.

36.hashable protocol: allows a type to be used as a key in dictionary or a set.

37.equatable: allow comparing two instances using ==
static func == (lhs: Product, rhs: Product) -> Bool

38.access control:
private: Accessible only within the declaration scope
fileprivate:  Accessible within the entire source file where it’s declared
internal: Accessible within the same module
public: ccessible from any module, but cannot be subclassed/overridden outside its defining module.
open:The most permissive level—accessible from any module, and can be subclassed/overridden outside its defining module (only applies to classes and their members).

39. nested type: defining a type within another type to reflect their relationship.

40.standard library: the core set of types and functions provided by swift.

41.explain the viewcontrolelr life cycle:
1)init
3)init(nib) :init viewcontroller form NIB
2)init(coder) : init from xib/storyboard
4)loadview: Creates/assigns the VC’s root view
5)viewdidload: Triggers once the view is fully loaded.
viewwilllayoutsubviews
viewdidlayoutsubvies
6)viewwillappear:
7)viewdidappear:
viewwilldisappear
viewdidappear
dealloc

42.frame bounds: frame is the postion of superview. 
bounds is own position, will have influence to subviews.

43.how to optimize uitableview performance: 
1.cell reuse
2.avoiding heavy computation
3.pre-calculating

44.auto layout: a constraint-based layout system to handle difference screen sizes.

45.what is intrinsic content size: the natural size a view need to display its content.

46.explain setneedslayout vs layoutifneeded
setneedslayout marks a views for update
layoutifneed forces it immediately

47.responder chain  event handling
event delivery: 
use pointinside: WithEvent to find view within the point.
use hitTest withEvent: to find the hitTest view.

responder chain: 
find the view who can handle the action from a chain of views. 
superview viewcontroller window uiapplication appdelete, if all of the can not hanlde the aciton, the action will be discarded


48.how to hanle keyboard covering a textfiled:
observe keyboard notification and adjust the view's content offset or ocnstraints.

49.UIStackView: a view that manages a collection of subviews in a linear layout.

50.difference between draw: and layoutsubview:
draw if for custom drawing with core grphics; 
layoutsubviews: is for positioning subviews.


51.safe area: the area of a view that is not coverd by bars(status bar, navigation bar, etc.)

52.how to create a custion view
subclass uiview and override init(frame:) init coder:

53.what is uiappearance
a protocol to customize the appearance of all instances of a clas

57.what is calayer: a low-level object for managing visual content, used by uiview.

58.off-screen rendering: when the gpu renders a layer in a separate buffer, copy to screen buffer. affecting perfermance.

59.how to reduce app launch time:
1.reduce dynamic frameworks.
2.reduce c++ static construction function.
3.replae +load with +initialize
4.lazy load properties.
5.asynchronize load third-part sdk.
6.do not initialze none critical sdk while app launching
7.reduce redundant code / libraries.
8.do not lag the main thread.


61.what is insturments: a performance analysis tools for profilling cpu /memory/energy usage.

62.how to detect memory leaks: using the leaks instrument or the memory graph debugger in xcode.

63.core graphics: a 2d drawing engine for creating shapes, paths, and gradients.

64.core animation: a foramwork for creating smooth/hard-ware-accelerated animations.

65.explain uigesturerecognizer: an object that detects specific touch patterns like taps,swipes,pinches.

72.what is dynamic type: a feature allowing users to choose their perferred text size.

73.UIWindow: UIWindow-UIView-UIResponder
the backdrop for you app's ui and the object that dispatches events to views.


76.swiftui: a declarative framework for building uis across all apple platforms.

77.what is a view in swiftui
a protocol that describes part of a user interface.

78.explain @state
a property wrapper for simple, local state within a view.
when the property changed with @state, system will automatically call body to refresh the UI.

79.@binding
a property wrapper used the share sate between a parent and child view.

80.@observedobject: used for external objects that conform to observableobject.

81.explain @stateobject: similar to @observedobject but ensures the object is only created once.

82.explain environmentobject: a way share data across many views without passing it explicitly.

83. what is body property.
the computed property where you define a view's content.

84. what is vstack hstack and zstack.
vertical,horizonal,and depth-based layout containers.

85.how to perform navigatior in swiftui
use NavigationView

86.what is list in swiftui
a container that presents data in a single column of scrollable rows.
like uiscrollview in uikit.

87.how to handle user input in swiftui.
using components likes TextFiled Toggle Slider
‘
88.what is modifier:
a method that creates a new view by transforming an existing one.

89.how to perfrom animations in swiftui
use nimation() or withAnimation()

90.what is viewBuilder:
A parameter attribute that allow creating views form closures.

91.how to integrate uikit into swiftui
use uiviewrepresentable uiviewcontrollerrepresentable

92.how to integrate swfitui into uikit
use uihostingcontroller

93.what is anyview
a type, erased view used when hyou need to return different view types.

94.what is @appstorage
a property wrapper for reading /writing to userdefault

95.what is scenestorage
used for state restoration within a specific scene.

96.how to handle life-cycle in swiftui
use onappear() and ondisapper

97.what is geometryreader
a view that provides its parent's size and coordinate space to its children

98.how to create custom modifier.
comform to the viewmodifier protocol

struct PrimaryButtonModifier: ViewModifier {
    // 可选：添加可配置参数（让 Modifier 更灵活）
    let bgColor: Color
    let cornerRadius: CGFloat
    
    // 2. 实现 ViewModifier 协议的核心方法：body(content:)
    // content：被修改的原视图（比如 Button/Text）
    func body(content: Content) -> some View {
        content
            .font(.headline)          // 修改字体
            .padding(.vertical, 12)   // 垂直内边距
            .padding(.horizontal, 24) // 水平内边距
            .background(bgColor)      // 背景色（可配置）
            .foregroundColor(.white)  // 文字色
            .cornerRadius(cornerRadius) // 圆角（可配置）
            .shadow(radius: 3)        // 阴影
    }
    
    // 可选：提供默认参数的初始化方法
    init(bgColor: Color = .blue, cornerRadius: CGFloat = 8) {
        self.bgColor = bgColor
        self.cornerRadius = cornerRadius
    }
}

99.what is perference in swiftui
a way to pass data from child views upto parent views.

100.expalin asyncimage
a view that loads and displays an image from a url asynchronnously.

    var body: some View {
        // 最简用法：仅传URL，默认占位符为空白
        AsyncImage(url: imageURL)
            .frame(width: 200, height: 200)
    }


101.concurrency: executing multiple tasks at the same time

102.gcd(grand central dispatch):
a low-api for managing concurrent tasks using queues.

103.what is a serial quque.
a queue that executes one task at a time in order.

104.what is concurrent queue.
a queue that that can execute multiple task simultaneously.

105.what is main queue.
a serial queue taht runs on the main thread for ui tasks.

106.difference between sync and async
sync waits for completion; async returns immediately.
sync can not create new thread, add task on current thread
async can add new threads. will not lag current thread.

107.what is deadlock
when two or more task wait for each other to finish, stoping all progress

108.what is rece condition.
when multiple threads access shared data at the same time, leading to unpredicatable results.

109.hwo to fix rece condictions.
use lock,serial queues, or semaphores.

110.waht is dipatchGroup
a way to monitor a set of tasks and perform and action when all finish.

111.what is dispatchworkitem
an object taht encapsulates a block of code to be executed.

112.explain operation and oprationqueue
a high-level obstraction over gcd that supports dependencies and cancellation.

113.what is quality of service
a way to prioritize task.

114.what is async await
a modern swift syntax for writing asynchronous code that looks sychronous.

115.what is a task
a unit of asychronous work in the new concurrency model.

116.what is taskGroup
A way to manage a dynamic number of child tasks.

117.what is an actor.
a reference type that protects its state form data races ensuring serial access.

118.what is @mainActor
a global actor taht ensures code runs on the main thread.

119.what is sendable protorol
a protocol indicating a type is safe to pass across concurrency boundaries.
struct User: Sendable { // 可省略，编译器自动推断
    let id: Int
    let name: String // 所有属性为 let（不可变）
}

120.how to cancel a task.
use task.cancel() and check task.iscanceled whthin the task

121.what is checkedcontinuation
a bridge between traditional completion handlers and async / await

122.what is task.sleep()
suspends the current task for a give duration without blocking the thread.

123.difference between task and task.detached
task inherits contect , detached does not

124.what is structured concurrency
a model where the lifetime of child tasks is tied to their parent.

125.what is priority inversion
when a low-priority task holds a resource needed by a high-priority task.

126.what is semaphore
a synchronization primitive that controls access to a shared resouce using counter.

127.what is thread sanitizer
a tools to find data race in your code.


128.how to handle errors in async fucctions.
use async throws and try await

// 2. 声明 async throws 异步函数（可能抛出错误）
func fetchUserData(from urlString: String) async throws -> Data {
    // 校验URL（失败则抛错）
    guard let url = URL(string: urlString) else {
        throw NetworkError.invalidURL
    }
    
    // 异步请求（URLSession.data(from:) 本身是 async throws 函数）
    do {
        let (data, response) = try await URLSession.shared.data(from: url)
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
            throw NetworkError.requestFailed("Invalid status code")
        }
        return data
    } catch {
        throw NetworkError.requestFailed(error.localizedDescription)
    }
}



129.what is asyncsequeue 
a protocol for values that are delivered asynchronously over time.
// 示例：异步流式读取网络数据（URLSession.bytes 是 AsyncSequence）
func streamNetworkData(from urlString: String) async throws {
    guard let url = URL(string: urlString) else {
        throw NSError(domain: "InvalidURL", code: -1)
    }
    
    // 获取异步字节序列
    let (bytesSequence, _) = try await URLSession.shared.bytes(from: url)
    
    // 用 for-await-in 异步遍历序列（每拿到一批字节就执行一次）
    var totalBytes = 0
    for try await byteChunk in bytesSequence {
        totalBytes += byteChunk.count
        print("Received \(byteChunk.count) bytes, total: \(totalBytes)")
    }
    print("Stream completed, total bytes: \(totalBytes)")
}


130. what is taskpriority
defines how much cpu time a task should get relative to other.

import Foundation

// 示例1：创建不同优先级的任务
func taskPriorityExample() async {
    // 1. 高优先级任务（UI相关）
    let highPriorityTask = Task(priority: .high) {
        print("High priority task started")
        try await Task.sleep(nanoseconds: 500_000_000) // 模拟耗时UI操作
        print("High priority task completed")
        return "UI updated"
    }
    
    // 2. 低优先级任务（后台缓存）
    let lowPriorityTask = Task(priority: .low) {
        print("Low priority task started")
        try await Task.sleep(nanoseconds: 500_000_000) // 模拟后台操作
        print("Low priority task completed")
        return "Cache synced"
    }
    
    // 等待结果（高优先级任务通常会先完成）
    let highResult = await highPriorityTask.value
    let lowResult = await lowPriorityTask.value
    print("Results: \(highResult), \(lowResult)")
}
































































































































































